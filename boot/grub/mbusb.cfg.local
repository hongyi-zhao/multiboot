# mbusb 的方法中，有些也是失败的：
# 比如 freebsd，这类问题可以用我的 dd 方法补充。

# 在基于 dd 的sysrcd的启动中，如果有多个可用 的 sysrcd，实际上启动的是最先找到的那个。
# 要精确控制启动相应的 sysrcd，似乎需要设定 相应的一些变量，比如： img_dev ，但是
# 基于 chainloader 的方法，无法之间传递变量，是这个方法的缺点。


    insmod part_msdos
    insmod ntfs
	
    insmod part_gpt
    insmod ext2
    insmod iso9660
    insmod regexp
    insmod loopback
        
    insmod chain

unset cd_label_tot

set origroot=$root

for i in (*)/EFI/* (*)/efi/* (*)/boot/loader.efi; do
       
        regexp -s _part '^(\(.*\))' "$i"

        probe --set fs --fs "$_part"
        if [ x$fs = xiso9660 ]; then
        
          probe --set cd_label --label "$_part"
          
          # arch 用这个方法不行，需要修改相关的启动配置配置后用grub调用。
          if regexp '^ARCH_[1-9][0-9]+$' "$cd_label"; then continue; fi
          
          # 优先使用基于 GRUBX64 / grubx64  相关efi文件的启动方法。
          # 因为观察到，在 GRUBX64 / grubx64 和 BOOTX64 / bootx64 相关的efi文件都存在的情况下，
          # chainloader GRUBX64 / grubx64 相关 efi 才会成功。
          for file in $i/GRUBX64.* $i/grubx64.*; do
            if regexp -s 1:loader_root -s 2:loader_dirname 3:loader_basename '^(\(.*\))(/.*/)([^/]+(efi|EFI))$' "$file"; then
              # 去重处理：     
              if regexp "$cd_label" "$cd_label_tot"; then continue; fi
                cd_label_tot="${cd_label_tot} ${cd_label}"
                
                menuentry "$cd_label on $loader_root ($loader_basename) ->" "$loader_root" "$loader_dirname$loader_basename" {
                set root=$2
                chainloader $3
                boot
                set root=$origroot
              }  
       
           fi          
         
         done

         
         for file in $i/BOOTX64.* $i/bootx64.*; do
        
           if regexp -s 1:loader_root -s 2:loader_dirname 3:loader_basename '^(\(.*\))(/.*/)([^/]+(efi|EFI))$' "$file"; then       
                if regexp "$cd_label" "$cd_label_tot"; then continue; fi
                cd_label_tot="${cd_label_tot} ${cd_label}"
                           
                menuentry "$cd_label on $loader_root ($loader_basename) ->" "$loader_root" "$loader_dirname$loader_basename" {
                set root=$2
                chainloader $3
                boot
                set root=$origroot                
              }  
       
           fi         
         
         done
         
         # for Freebsd
           if regexp -s 1:loader_root -s 2:loader_dirname 3:loader_basename '^(\(.*\))(/boot/)(loader.efi)$' "$i"; then   
                if regexp "$cd_label" "$cd_label_tot"; then continue; fi
                cd_label_tot="${cd_label_tot} ${cd_label}"
           
                menuentry "$cd_label on $loader_root ($loader_basename) ->" "$loader_root" "$loader_dirname$loader_basename" {
                set root=$2
                chainloader $3
                boot
                set root=$origroot                
              }  
       
           fi         
    
         
          # for Microsoft Windows           
          elif [ x$fs = xntfs ]; then
          
           for file in $i/BOOTX64.* $i/bootx64.*; do
        
             if regexp -s 1:loader_root -s 2:loader_dirname 3:loader_basename '^(\(.*\))(/.*/)([^/]+(efi|EFI))$' "$file"; then    
           
               if regexp "Microsoft Windows" "$cd_label_tot"; then continue; fi
               cd_label_tot="${cd_label_tot} Microsoft Windows"
                
               menuentry "Windows on $loader_root ($loader_basename) ->" "$loader_root" "$loader_dirname$loader_basename" {
               set root=$2
               chainloader $3
               boot
               set root=$origroot
               }  
       
             fi         
         
           done
            
        fi 
           
         
done

